### 题目1：51NOD3199

题目：有一个初始为空的栈，我们对这个栈进行 n次操作，操作共分为 2种：

1.1 x（将数字 x放入栈）
2.2 （将栈顶元素弹出）

对于第 2 种操作，你需要把弹出的这个数字输出，如果进行操作 2时，栈为空，则输出 "empty"。

例如： n=5 ，对应的操作为：

1 123 （操作后栈里面的元素为： 123 ）
1 234 （操作后栈里面的元素为： 123,234 ）
2 （输出： 234 ，操作后栈里面的元素为： 123 ）
2 （输出： 123 ，操作后栈里面的元素为：空）
2 （输出： "empty" ）

对应后面 33 个第 22 类操作，你的程序需要输出，

234
123
empty



思路：

1.使用stack来模拟操作

2.对于每一操作行，先读入数字，若为1则执行入栈操作，若为2执行出栈操作



代码：

```c++
#include<bits/stdc++.h>

using namespace std;

int main(){
	stack<int> s;
	int op,x;
	int n;
	cin>>n;
	while(n--){
		cin>>op;
		if(op == 1){
			cin>>x;
			s.push(x);
		}else if(op == 2){
			if(s.empty()){
				cout<<"empty"<<endl;
			}else{
				cout<<s.top()<<endl;
				s.pop();
			}
		}
	} 
	return 0;
}
```



### 题目2 P1540

题目：

小晨的电脑上安装了一个机器翻译软件，他经常用这个软件来翻译英语文章。

这个翻译软件的原理很简单，它只是从头到尾，依次将每个英文单词用对应的中文含义来替换。对于每个英文单词，软件会先在内存中查找这个单词的中文含义，如果内存中有，软件就会用它进行翻译；如果内存中没有，软件就会在外存中的词典内查找，查出单词的中文含义然后翻译，并将这个单词和译义放入内存，以备后续的查找和翻译。

假设内存中有 M 个单元，每单元能存放一个单词和译义。每当软件将一个新单词存入内存前，如果当前内存中已存入的单词数不超过 M−1，软件会将新单词存入一个未使用的内存单元；若内存中已存入 M个单词，软件会清空最早进入内存的那个单词，腾出单元来，存放新单词。

假设一篇英语文章的长度为 N个单词。给定这篇待译文章，翻译软件需要去外存查找多少次词典？假设在翻译开始前，内存中没有任何单词。



思路：

1.使用vector来当作内存，并且使用时其中存储元素个数不超过N个

2.vector在执行删除元素、插入元素时按照队列的规则。

3.每当有元素入队，则计数加一



代码：

```c++
#include<bits/stdc++.h>

using namespace std;

int main(){
	vector<int> q;
	int m,n;
	
	cin>>m>>n;
	int cnt = 0;
	vector<int>::iterator it;
	for(int i = 0 ; i < n ; i++){
		int t;
		cin>>t;
		it = find(q.begin(),q.end(),t);
		if(it == q.end()){
			if(q.size() < m){
				q.push_back(t);
				
			}else{
				q.erase(q.begin());
				q.push_back(t);
				
			}
			cnt++;
		}else{
			
		}
	}
	
	cout<<cnt<<endl;
	return 0;
}
```



### 题目3 HDU1062

题目：

Ignatius likes to write words in reverse way. Given a single line of text which is written by Ignatius, you should reverse all the words and then output them.

The input contains several test cases. The first line of the input is a single integer T which is the number of test cases. T test cases follow.
Each test case contains a single line with several words. There will be at most 1000 characters in a line.

For each test case, you should output the text which is processed.



思路：

1.读入一行文本需要使用getline()方法

2.使用字符串ans存放要输出的结果。遍历读入的一行文本，如果遇到空格，则说明已经读完一个单词且存入栈中，则出栈所有字符并放入要输出的字符串中；如果读到最后一个字符，则说明读完最后一个单词，出栈所有字符并放入要输出的字符串中；其他情况则直接字符入栈

3.输出ans



代码：

```c++
#include<bits/stdc++.h>

using namespace std;

int main(){
	int t;
	scanf("%d",&t);
	getchar();
	stack<char> s;
	char ch;
	string res = "";
	while(t--){
		getline(cin,res);
		//cout<<res<<endl;
		string ans = "";
		for(int i = 0 ; i < res.size() ; i++){
			
			if(res[i] == ' ' ){
				string temp = "";
				while(!s.empty()){
					ch = s.top();
					s.pop();
					temp += ch;
				}
				ans += temp;
				ans += " "; 
			}else if(i == res.size() -1){
				s.push(res[i]);
				string temp = "";
				while(!s.empty()){
					ch = s.top();
					s.pop();
					temp += ch;
				}
				ans += temp;
			}else{
				s.push(res[i]);
			}
		}
		
		cout<<ans<<endl;
		
	}
	return 0;
} 
```



### 题目4 P1449

题目：

所谓后缀表达式是指这样的一个表达式：式中不再引用括号，运算符号放在两个运算对象之后，所有计算按运算符号出现的顺序，严格地由左而右新进行（不用考虑运算符的优先级）。

本题中运算符仅包含 + - * /。保证对于 / 运算除数不为 0。特别地，其中 / 运算的结果需要**向 0 取整**（即与 C++ `/` 运算的规则一致）。

如：3*(5-2)+7对应的后缀表达式为：3.5.2.- *  7.+@。在该式中，`@` 为表达式的结束符号。`.` 为操作数的结束符号。



思路：

1.使用栈：操作数栈

2.读入符号时，出栈两个操作数并应用到该符号上，把结果存入操作数栈

3.读入到@时，操作数栈中结果即为计算结果



代码：

```c++
#include<bits/stdc++.h>

using namespace std;
stack<int> operand;//操作数 

void apply(char opt){
	
	int b = operand.top();
	operand.pop();
	int a = operand.top();
	operand.pop();
	int res;
	if(opt == '+'){
		res = a + b;
	}else if(opt == '-'){
		res = a - b;
	}else if(opt == '*'){
		res = a * b;
	}else if(opt == '/'){
		res = a / b;
	}
	
	operand.push(res);
}

int getNum(string s){
	int res = 0;
	for(int i = 0 ; i < s.size() ; i++){
		int digit = s[i] - '0';
		res = res*10 + digit;
	}
	return res;
}
string num = "";

int main(){
	char ch;
	bool first = true;
	while(true){
		scanf("%c",&ch);
		
		if(ch == '@'){//代表读入结束 
			cout<<operand.top();
			break;
		}else{
			if(ch == '.'){
				int t = getNum(num);
				operand.push(t);
				num = "";
			}else if( ch >= '0' && ch <= '9'){
				num += ch;
			}else{
				apply(ch);
			}
		}
	}
	return 0;
}
```

