### 题目1：UVA11175

题目：

Take any directed graph **D** with **n** vertices and **m** edges. You can make the Lying graph **E** of **D** in the following way. **E** will have **m** vertices, one for each edge of **D**. For example, if **D** has an edge **uv**, then **E** will have a vertex called **uv**. Now, whenever **D** has edges **uv** and **vw**, **E** will have an edge from vertex **uv** to vertex **vw**. There are no other edges in **E**.

You will be given a graph **E** and will have to determine whether it is possible for **E** to be the Lying graph of some directed graph D.

思路：

1.如果E中节点i和j有公共邻接点，则需要i和j的邻接点完全一致，否则不符合题目要求

代码:

```cpp
#include<bits/stdc++.h>
#define REP(i,b,e) for(int i = (b) ; i < (e) ; i++)
using namespace std;
const int MAX = 400;
int n,m;
int g[MAX][MAX];
bool solve(){
    REP(i,0,n)
        REP(j,0,n){
            bool flag1 = false;
            bool flag2 = false;
            REP(k,0,n){
                if(g[i][k] && g[j][k]){
                    flag1 = true;
                }

                if(g[i][k] ^ g[j][k]){
                    flag2 = true;
                }
            }

            if(flag1 && flag2)return false;
        }

    return true;
}

int main(){
    int N;
    cin>>N;
    memset(g,0,sizeof(g));

    for(int i = 1 ; i <= N ; i++){
        cin>>n;
        cin>>m;
        int u,v;
        memset(g,0,sizeof(g));
        for(int j = 0 ; j < m ; j++){
            cin>>u>>v;
            g[u][v] = 1;
        }

        if(solve()){
            cout<<"Case #"<<i<<": Yes"<<endl;
        }else{
            cout<<"Case #"<<i<<": No"<<endl;
        }

    }

    return 0;
}
```

### 题目2：POJ3275

题目：

Each of Farmer John's *N* cows (1 ≤ *N* ≤ 1,000) produces milk at a different positive rate, and FJ would like to order his cows according to these rates from the fastest milk producer to the slowest.

FJ has already compared the milk output rate for *M* (1 ≤ *M* ≤ 10,000) pairs of cows. He wants to make a list of *C* additional pairs of cows such that, if he now compares those *C* pairs, he will definitely be able to deduce the correct ordering of all *N* cows. Please help him determine the minimum value of *C* for which such a list is possible.

思路：

1.使用bitset数组P来记录节点邻接关系，p[i][j]表示有一条边从i到j

2.n个节点要有n*(n-1)/2对关系才能确定顺序，使用n*(n-1)/2减去通过传递闭包可得到的关系总数即为要增加的关系数目。（求传递闭包即为求出所有可达节点）

3.对每一个节点i，检查其他所有节点j的P[j][i]是否为1，若为1则把P[j]更新为P[j]和P[i]进行或操作的结果；统计P[i]的1的个数并求和，可得到通过传递闭包可得到的关系总数。

代码：

```cpp
#include<iostream>
#include<cstring>
#include<vector>
#include<bitset>
const int MAX = 1010;
using namespace std;
bitset<MAX> p[MAX];


int main(){
    int n,m;
    cin>>n>>m;
    int total = n*(n-1)/2;
    int now = 0;
    int ans;//ans = total - now

    int u,v;


    for(int i = 0 ; i < m ; i++){
        cin>>u>>v;
        p[u][v] = 1;    
    }

    for(int i = 1 ; i <= n ; i++){
        for(int j = 1 ; j <= n ; j++){
            if(p[j][i]){
                p[j] = p[i] | p[j];
            }
        }    
    }

    for(int i = 1 ; i <= n ; i++){
        now += p[i].count();
    }

    //cout<<"total is :"<<total<<" now is :"<<now<<endl;
    ans = total - now ;
    cout<<ans<<endl;

    return 0;
}
```

### 题目3：UVA572

题目：

GeoSurvComp地质调查公司负责探测地下油藏。GeoSurvComp每次只处理一个大的矩形区域，并创建一个网格，将土地划分成无数的方形地块。然后，它使用传感设备分别分析每个地块，以确定地块是否含有石油。 含有石油的地块称为口袋。如果两个储层相邻，那么它们就是同一个油藏的一部分。石油蕴藏量很大，可能包含无数的油穴。你的工作是确定在一个网格中有多少不同的石油储藏。

思路：

1.油田数目即为所给图连通分量个数

2.使用BFS或DFS对图进行遍历，统计连通分量个数

3.若一次搜索未全部遍历完所有点，则连通分量数加一，选择一个未遍历的点开始遍历

代码：

```cpp
#include<bits/stdc++.h>

using namespace std;

const int MAX = 110;
char area[MAX][MAX];
bool visited[MAX][MAX];

int dir[8][2] = {{-1,0},{-1,1},{0,1},{1,1},{1,0},{1,-1},{0,-1},{-1,-1}};
struct Node{
    int x;
    int y;
};

bool CHECK(int x , int y , int m , int n){
    if( x >= 1 && x <= m && y >= 1 && y <= n){
        return true;
    }
    return false;
}

void BFS(int x , int y,int m, int n){
    queue<Node> q;
    visited[x][y] = true;
    struct Node t;
    t.x = x;
    t.y = y;
    area[x][y] = '#';
    q.push(t);
    while(!q.empty()){
        struct Node now = q.front();
        q.pop();
        for(int i = 0 ; i < 8 ; i++){
            int tx = now.x + dir[i][0];
            int ty = now.y + dir[i][1];

            if(CHECK(tx,ty,m,n) && area[tx][ty] == '@' && !visited[tx][ty]){
                visited[tx][ty] = true;
                area[tx][ty] = '#';
                struct Node next ;
                next.x = tx;
                next.y = ty;
                q.push(next);
            }
        }
    } 
}


void solve(int m , int n){
    char ch;
    int cnt = 0;
    for(int i = 1 ; i <= m ; i++){
        for(int  j = 1 ; j <= n ; j++){
            cin>>ch;
            area[i][j] = ch;
        }
    }

    for(int i = 1 ; i <= m ; i++){
        for(int  j = 1 ; j <= n ; j++){
            if(!visited[i][j] && area[i][j] == '@'){
                cnt++;
                BFS(i,j,m,n);
            }
        }
    }

    cout<<cnt<<endl;
}



int main(){
    int m,n;
    while(cin>>m>>n){
        if(m == 0){
            break;
        }
        else{
            memset(visited,false,sizeof(visited));

            solve(m,n);
        }
    }
    return 0;
}
```

### 题目4：UVA1599

题目：

New labyrinth attraction is open in New Lostland amusement park. The labyrinth consists of n rooms connected by m passages. Each passage is colored into some color ci . Visitors of the labyrinth are dropped from the helicopter to the room number 1 and their goal is to get to the labyrinth exit located in the room number n.
Labyrinth owners are planning to run a contest tomorrow. Several runners will be dropped to the room number 1. They will run to the room number n writing down colors of passages as they run through them. The contestant with the shortest sequence of colors is the winner of the contest. If there are several contestants with the same sequence length, the one with the ideal path is the winner. The path is the ideal path if its color sequence is the lexicographically smallest among shortest paths.
Andrew is preparing for the contest. He took a helicopter tour above New Lostland and made a picture of the labyrinth. Your task is to help him find the ideal path from the room number 1 to the room number n that would allow him to win the contest.
Note: A sequence (a1, a2, . . . , ak) is lexicographically smaller than a sequence (b1, b2, . . . , bk) if there exists i such that ai < bi , and aj = bj for all j < i.



思路：

1.先从n反向BFS至1，求出最短路径长度

2.从1开始BFS至n,遍历时保证路径颜色最小





代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=100001; // 最大顶点数
struct Edge { // 边
    int u, v, c;
    Edge(int _u, int _v, int _c) : u(_u), v(_v), c(_c) {} // 默认构造函数
};
vector<Edge> edge; // 边的缓存，数组下标作为编号
vector<int> G[maxn]; // 邻接表存图，边用编号表示，提高效率；
int n, m, a, b, c;
int d[maxn], vis[maxn]; // d:终点到各个点的距离（层次）；vis：访问数组
void revBfs() { // 从终点开始遍历，计算到每个点的距离
    memset(d, 0, sizeof(d)); memset(vis, 0, sizeof(vis)); // 初始化
    queue<int> q;
    q.push(n-1); vis[n-1] = 1; // 终点入队
    while (!q.empty()) {
        int u = q.front(); q.pop(); // 顶点出队
        for (int e : G[u]) { // 每条邻边
            int v = (u == edge[e].u) ? edge[e].v : edge[e].u;
            if (vis[v] == 0) { // 未访问
                d[v] = d[u] + 1; // 距离/层次更新
                q.push(v);
                vis[v] = 1; // 标记访问
            }
        }
    }
}
void bfs() { // 从起点开始bfs，记录字典序最小的路径
    printf("%d\n", d[0]); // 最短距离
    memset(vis, 0, sizeof(vis)); // 初始化
    vector<int> next{0}, ans;
    for (int i=0; i < d[0]; i ++) { // 分层遍历
        int minColor=0x3fffffff; // 最小颜色值
        for (int u : next) // 该层顶点（找出本层到下一层的最小颜色值）
            for (int e : G[u]) { // 所有边
                int v = (u == edge[e].u) ? edge[e].v : edge[e].u; // 确定下一个顶点
                if (d[u] == d[v]+1 && edge[e].c < minColor) minColor = edge[e].c; // 找出可达终点的最小颜色边  
            }
        ans.push_back(minColor); // 存储最小颜色
        vector<int> tnext; // 临时存储
        for (int u : next) // 将本层到下一层颜色值满足最小的点加入下一轮next
            for (int e : G[u]) {
                int v = (u == edge[e].u) ? edge[e].v : edge[e].u;
                if (d[u] == d[v]+1 && vis[v] == 0 && edge[e].c == minColor) {
                    tnext.push_back(v);
                    vis[v] = 1;
                }
            }
        next = tnext; // 更新next数组
    }
    for (int i=0; i < ans.size(); i ++) printf("%d%s", ans[i], i == ans.size()-1 ? "\n" : " ");
}
int main() {
    while (scanf("%d %d", &n, &m) == 2) {
        edge.clear(); fill(G, G+maxn, vector<int>{}); // 初始化
        while (m --) {
            scanf("%d %d %d", &a, &b, &c);
            if (a == b) continue; // 处理自环
            G[a-1].push_back(edge.size()); // 无向图，从0开始存储
            G[b-1].push_back(edge.size());
            edge.push_back({a-1,b-1,c}); // 边缓存
        }
        revBfs();
        bfs();
    }
    return 0;
}

```
