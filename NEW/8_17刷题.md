### 题目1：51NOD3202

题目：给出 2个集合 A,B ，判断 B  是否为 A的子集。由于集合 A,B 本身都可能存在重复的元素，因此如果 B中某个元素的数量多于 A，也不认为 B是 A的子集。子集忽略集合元素的顺序。

思路：

1.使用两个map分别存储A和B的元素及其个数

2.若B的个数多于A，则不符合；若B中存在A中没有的元素，则不符合

3.对于B中每个键值对，若数量多于A中对应元素个数，则不符合

4.剩余情况则符合题目要求



代码：

```c++
#include<bits/stdc++.h>

using namespace std;
map<int,int> A;//(元素，数量)
map<int,int> B;
int main(){
	int t;
	cin>>t;
	while(t--){
		A.clear();
		B.clear();
		int m,n;
		cin>>m>>n;
		int elem;
		for(int i = 0 ; i < m ; i++){
			cin>>elem;
			if(A.find(elem) == A.end()){
				A.insert(pair<int,int>(elem,1));
			}else{
				int temp = A[elem];
				temp++;
				A[elem] = temp;
			}
		}
		
		for(int i = 0 ; i < n ; i++){
			cin>>elem;
			if(B.find(elem) == B.end()){
				B.insert(pair<int,int>(elem,1));
			}else{
				int temp = B[elem];
				temp++;
				B[elem] = temp;
			}
		}
		
		int lenA,lenB;
		lenA = A.size();
		lenB = B.size();
		if(lenB > lenA){
			cout<<"No"<<endl;
		}else{
			bool flag = true;
			for(map<int,int>::iterator it = B.begin() ; it != B.end() ; it++){
				int elem = it->first;
				int cnt = it->second;
				if( A.find(elem) == A.end()){
					flag = false;
					break;
				}else{
					if(cnt > A.find(elem)->second){
						flag = false;
						break;
					}else{
						
					}
				}
			}
			
			if(flag){
				cout<<"Yes"<<endl;
			}else{
				cout<<"No"<<endl;
			}
		}
		
	} 
	return 0;
}
```





### 题目2：51NOD2068

题目：桌上有一叠牌，从顶面的牌开始往底面依次编号为 1 ～ n。当至少还剩两张牌时进行以下操作：把第一张扔掉，然后把新的第一张放到整叠牌的最后。

思路：使用队列来模拟操作，当队列长度大于等于2时，输出队头元素并丢弃，把新队头元素放入队尾，最后输出剩下的元素。



代码：

```
#include<bits/stdc++.h>

using namespace std;

int main(){
	int n;
	cin>>n;
	queue<int> q;
	for(int i = 1 ; i <= n ; i++){
		q.push(i); 
	}
	
	while(q.size() >= 2){
		int a = q.front();
		cout<<a<<" ";
		q.pop();
		a = q.front();
		q.pop();
		q.push(a);
	}
	
	cout<<q.front();
	return 0;
}
```





