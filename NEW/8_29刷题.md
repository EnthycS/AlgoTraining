### 题目1：POJ2488

题目：

The knight is getting bored of seeing the same black and white squares again and again and has decided to make a journey  
around the world. Whenever a knight moves, it is two squares in one direction and one square perpendicular to this. The world of a knight is the chessboard he is living on. Our knight lives on a chessboard that has a smaller area than a regular 8 * 8 board, but it is still rectangular. Can you help this adventurous knight to make travel plans?

Find a path such that the knight visits every square once. The knight can start and end on any square of the board.

思路：

1.使用DFS进行搜索，搜索步数达到m*n即找到一条符合要求的路径

2.搜索时要按字典序尝试开始点，即A1、A2、A3......这样的顺序来选择初始点并记录符合条件的路径。

代码：

```cpp
#include <cstdio>
#include <iostream>
#include <cstring>
#include <queue>
#include <vector>
#define sf scanf
#define pf printf

using namespace std;
const int step[][2] = { {-1,-2} ,{1,-2} ,{-2,-1} ,{2,-1} , {-2,1} , {2,1} , {-1,2} ,  {1,2}  };         //马的step 按字典序排列
const int maxn = 100;
bool vis[maxn][maxn];
int n,m;
int vis_cnt;
vector<int> ans;
bool DFS(int row,int col){
    vis[row][col] = 1;
    vis_cnt++;
    if(vis_cnt == n * m){
        ans.push_back(row);
        ans.push_back(col);
        return true;
    }
    for(int i = 0;i < 8;++i){
        int nrow = row + step[i][0],ncol = col + step[i][1];
        if(nrow >= 0 && nrow < n && ncol >= 0 && ncol < m && !vis[nrow][ncol]){
            if( DFS(nrow,ncol) ){
                ans.push_back(row);
                ans.push_back(col);
                return true;
            }
        }
    }
    vis_cnt--;
    vis[row][col] = 0;
    return false;
}


int main(){
    int T,ca = 0;
    sf("%d",&T);
    while( T-- ){
        sf("%d%d",&n,&m);
        bool ANS = false;
        memset(vis,0,sizeof(vis));
        vis_cnt = 0;
        ans.clear();
        for(int j = 0;j < m && !ANS;++j){
            for(int i = 0;i < n && !ANS;++i){
                if(DFS(i,j)){
                    ANS = true;
                }
            }
        }

        pf("Scenario #%d:\n",++ca);
        if(ANS){
            for(int i = ans.size() - 1;i >= 0;i -= 2){
                pf("%c%d",ans[i] + 'A',ans[i - 1] + 1);
            }
            pf("\n");
        }
        else pf("impossible\n");
        pf("\n");
    }
    return 0;
}
```

### 题目2：POJ1144

题目：

A Telephone Line Company (TLC) is establishing a new telephone cable network. They are connecting several places numbered by integers from 1 to N . No two places have the same number. The lines are bidirectional and always connect together two places and in each place the lines end in a telephone exchange. There is one telephone exchange in each place. From each place it is  
possible to reach through lines every other place, however it need not be a direct connection, it can go through several exchanges. From time to time the power supply fails at a place and then the exchange does not operate. The officials from TLC realized that in such a case it can happen that besides the fact that the place with the failure is unreachable, this can also cause that some other places cannot connect to each other. In such a case we will say the place (where the failure  
occured) is critical. Now the officials are trying to write a program for finding the number of all such critical places. Help them.

思路：

1.本题目可转化为无向图求割点数目的问题

2.使用链式前向星建立好无向图之后，对每个点都当作root使用一次tarjan算法，使用一个集合set存储割点（保证不重复），最后输出set大小即可。

代码：

```cpp
#include <cstdio>
#include <iostream>
#include <cstring>
#include <queue>
#include <vector>
#include <set>
#include <string.h>

using namespace std;

const int MAX = 110;

struct Edge{
    int to;
    int next;
}e[MAX*MAX];
int head[MAX];
int cnt,root,num;
set<int> s;

int low[MAX],dfn[MAX];

void init(){
    memset(head,0,sizeof(head));
    memset(low,0,sizeof(low));
    memset(dfn,0,sizeof(dfn));
    cnt = num  = 0;
    s.clear();
}

void add(int u, int v){
    e[++cnt].next = head[u];
    e[cnt].to = v;
    head[u] = cnt; 
}

void tarjan(int u , int fa){
    dfn[u] = low[u] = ++num;

    int count = 0;
    for(int i = head[u] ; i ; i = e[i].next){
        int v = e[i].to;
        if(v == fa){
            continue;
        }

        if(!dfn[v]){
            tarjan(v,u);
            low[u] = min(low[u],low[v]);
            if(low[v] >= dfn[u]){
                count++;
                if(u != root || count > 1){
                    s.insert(u);
                }
            }
        }else{
            low[u] = min(low[u],dfn[v]);

        }

    }
}

int main(){
    int n,u,v;
    while(cin>>n){

        if(n == 0)break;
        init();
        while(cin>>u && u){
            while(true){
                char ch = getchar();
                if(ch == '\n'){
                    break;
                }
                cin>>v;
                add(u,v);
                add(v,u);

            }
        }

        for(int i = 1 ; i <= n ; i++){
            if(!dfn[i]){
                root = i;
                tarjan(i,0);
            }
        }

        cout<<s.size()<<endl;
    }
    return 0;
}
```
