## A

### Problem Statement

Given eight integers S1​,S2​,…, and S8​, print `Yes` if they satisfy all of the following three conditions, and `No` otherwise.

- The sequence (S1​,S2​,…,S8​) is monotonically non-decreasing. In other words, S1​≤S2​≤⋯≤S8​.
- S1​,S2​,…, and S8​ are all between 100 and 675, inclusive.
- S1​,S2​,…, and S8​ are all multiples of 25.

### Constraints

- 0≤Si​≤1000
- All input values are integers.

##### 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;

void solve(){
    int a[8];
    int now,pre;
    bool flag = true;
    for(int i = 0 ; i < 8 ; i++){
        cin>>a[i];
    }
    for(int i = 1 ; i < 8 ; i++){
        now = a[i];
        pre = a[i-1];
        if(now >= pre && now % 25 == 0 && pre % 25 == 0 && now >= 100 && now <= 675 &&  pre >= 100 && pre <= 675){

        }else{
            flag = false;
            break;
        }
    }

    if(flag){
        cout<<"Yes"<<endl;
    }else{
        cout<<"No"<<endl;
    }
}

int main(){

    solve();

    return 0;
}
```

## B

### Problem Statement

Takahashi ate N plates of sushi at a sushi restaurant. The color of the i-th plate is represented by a string Ci​.

The price of a sushi corresponds to the color of the plate. For each i=1,…,M, the sushi on a plate whose color is represented by a string Di​ is worth Pi​ yen a plate (yen is the currency of Japan). If the color does not coincide with any of D1​,…, and DM​, it is worth P0​ yen a plate.

Find the total amount of the prices of sushi that Takahashi ate.

### Constraints

- 1≤N,M≤100
- Ci​ and Di​ are strings of length between 1 and 20, inclusive, consisting of lowercase English letters.
- D1​,…, and DM​ are distinct.
- 1≤Pi​≤10000
- N, M, and Pi​ are integers.

##### 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;

int n,m;

struct Node{
    string color;
    int price;
}menu[101];

int search(string ate){
    for(int i = 1 ; i < m + 1; i++){
        if(ate == menu[i].color){
            return i;
        }
    }

    return 0;
}

void solve(){
    cin>>n>>m;
    string ate[n];
    for(int i = 0 ; i < n ; i++){
        cin>>ate[i];
    }

    for(int i = 1 ; i < m+1 ; i++){
        string temp;
        cin>>temp;
        menu[i].color = temp;
    }

    for(int i = 0 ; i < m+1 ; i++){
        int temp;
        cin>>temp;
        menu[i].price = temp;
    }

    int ans = 0;
    for(int i = 0 ; i < n ; i++){
        int pos = search(ate[i]);
        ans += menu[pos].price;
    }
    cout<<ans<<endl;
}

int main(){

    solve();

    return 0;
}
```

## C

### Problem Statement

N people numbered 1 through N tossed a coin several times. We know that person i's tosses resulted in Ai​ heads and Bi​ tails.

Person i's **success rate** of the tosses is defined by Ai​+Bi​Ai​​. Sort people 1,…,N in descending order of their success rates, with ties broken in ascending order of their assigned numbers.

### Constraints

- 2≤N≤2×10^5
- 0≤Ai​,Bi​≤10^9
- Ai​+Bi​≥1
- All input values are integers.

##### 思路：

1.由于所给数据范围很大，使用long long型数据；为了不损失rate的精度，保存分子A与分母B

2.比较rate1与rate2大小可转化为比较x.a * y.b 和 y.a * x.b

##### 代码：

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

struct Player {
    long long a;
    long long b;
    int id;
};

bool cmp(const Player &x, const Player &y) {
    // 比较x.a * y.b 和 y.a * x.b
    long long left = x.a * y.b;
    long long right = y.a * x.b;

    if (left != right) {
        return left > right;  // 降序排列
    } else {
        return x.id < y.id;  // 索引升序
    }
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int N;
    cin >> N;
    vector<Player> players(N);

    for (int i = 0; i < N; ++i) {
        cin >> players[i].a >> players[i].b;
        players[i].id = i + 1;  // 选手编号从1开始
    }

    // 自定义排序
    sort(players.begin(), players.end(), cmp);

    // 输出结果
    for (int i = 0; i < N; ++i) {
        cout << players[i].id;
        if (i != N - 1) {
            cout << " ";
        }
    }
    cout << endl;

    return 0;
}
```

## D

### Problem Statement

We have a grid with H horizontal rows and W vertical columns. We denote by (i,j) the cell at the i-th row from the top and j-th column from the left. Each cell in the grid has a lowercase English letter written on it. The letter written on (i,j) equals the j-th character of a given string Si​.

Snuke will repeat moving to an adjacent cell sharing a side to travel from (1,1) to (H,W). Determine if there is a path in which the letters written on the visited cells (including initial (1,1) and final (H,W)) are `s` → `n` → `u` → `k` → `e` → `s` → `n` →…, in the order of visiting. Here, a cell (i1​,j1​) is said to be an adjacent cell of (i2​,j2​) sharing a side if and only if ∣i1​−i2​∣+∣j1​−j2​∣=1.

Formally, determine if there is a sequence of cells ((i1​,j1​),(i2​,j2​),…,(ik​,jk​)) such that:

- (i1​,j1​)=(1,1),(ik​,jk​)=(H,W);
- (it+1​,jt+1​) is an adjacent cell of (it​,jt​) sharing a side, for all t (1≤t<k); and
- the letter written on (it​,jt​) coincides with the (((t−1)mod5)+1)-th character of `snuke`, for all t (1≤t≤k).

### Constraints

- 2≤H,W≤500
- H and W are integers.
- Si​ is a string of length W consisting of lowercase English letters.

##### 思路：

1.dfs搜索图

##### 代码：

```cpp
#include <bits/stdc++.h>

using namespace std;
const int MAX = 510;
int h,w;
bool flag = false;
char grid[MAX][MAX];
bool visited[MAX][MAX];
void init(){
    cin>>h>>w;
    for(int i = 1 ; i <= h ; i++){
        for(int j = 1 ; j <= w ; j++){
            visited[i][j] = false;
        }
    }



    for(int i = 1 ; i <= h ; i++){
        string temp ;
        cin>>temp;
        for(int j = 1 ; j <= w ; j++){
            grid[i][j] = temp[j-1];
        }

    }



}
bool CHECK(int cnt,char ch,int x , int y){
    string pattern = "snuke";
    int pos = cnt % 5;
    if(x >= 1 && x <= h && y >= 1 && y <= w && ch == pattern[pos] && !visited[x][y]){
        return true;
    }else{
        return false;
    }
}

int dir[4][2] = {{-1,0},{1,0},{0,1},{0,-1}};
void dfs(int x , int y , int cnt){
    if(x == h && y == w ){
        flag = true;
    }else{
        cnt++;
        visited[x][y] = true;
    }

    for(int i = 0 ; i < 4 ; i++){
        int nx = x + dir[i][0];
        int ny = y + dir[i][1];

        if(CHECK(cnt,grid[nx][ny],nx,ny)){
            dfs(nx,ny,cnt);
        }else{

        }
    }



}


void solve(){
    init();
    if(grid[1][1] != 's'){
        cout<<"No"<<endl;
    }else{
        visited[1][1] = true;
        int cnt = 0;
        dfs(1,1,cnt);
        if(flag){
            cout<<"Yes"<<endl;
        }else{
            cout<<"No"<<endl;
        }
    }
}

int main(){
    solve();
    return 0;
}
```

## E

### Problem Statement

You are given a length-N sequence A=(A1​,A2​,…,AN​) consisting of 0, 1, and 2, and a length-N string S=S1​S2​…SN​ consisting of `M`, `E`, and `X`.

Find the sum of mex(Ai​,Aj​,Ak​) over all tuples of integers (i,j,k) such that 1≤i<j<k≤N and Si​Sj​Sk​= `MEX`. Here, mex(Ai​,Aj​,Ak​) denotes the minimum non-negative integer that equals neither Ai​,Aj​, nor Ak​.

### Constraints

- 3≤N≤2×10^5
- N is an integer.
- Ai​∈{0,1,2}
- S is a string of length N consisting of `M`, `E`, and `X`.

##### 思路：

1. **暴力法不可行**：直接枚举所有可能的三元组 O(N^3) 显然不行，因为 N 可达 2×10^5。

2. **关键观察**：对于每个 'E' 位置 j，计算它作为中间元素时的贡献。这样可以将问题分解为：
   
   - 前驱部分：j 前面有多少 'M' 且 A[i] = a
   - 后继部分：j 后面有多少 'X' 且 A[k] = b
   - 对每个 (a,b) 组合计算 mex(a, A[j], b)

3. **预处理**：
   
   - 前缀数组：记录每个位置前 'M' 中 0,1,2 的数量
   - 后缀数组：记录每个位置后 'X' 中 0,1,2 的数量

4. **高效计算**：对每个 'E' 位置 j，累计所有可能的 a (0-2) 和 b (0-2) 的组合：
   
   - 前缀 a 的数量 × 后缀 b 的数量 × mex(a, A[j], b)

##### 代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

int mex(int a, int b , int c){
    for(int x = 0 ; x <= 3 ; x++){
        if(a != x && b != x && c != x){
            return x;
        }
    }
}



void solve(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int N;
    cin>>N;
    vector<int> A(N);

    for (int i = 0; i < N; i++) cin >> A[i];
    string S;
    cin >> S;

    vector<array<int, 3>> prefix_m(N + 1);
    for (int i = 0; i < N; i++) {
        prefix_m[i + 1] = prefix_m[i];
        if (S[i] == 'M') {
            prefix_m[i + 1][A[i]]++;
        }
    }

    vector<array<int, 3>> suffix_x(N + 2);
    for (int i = N - 1; i >= 0; i--) {
        suffix_x[i] = suffix_x[i + 1];
        if (S[i] == 'X') {
            suffix_x[i][A[i]]++;
        }
    }

    ll ans = 0;
    for (int j = 0; j < N; j++) {
        if (S[j] != 'E') continue;

        int e_val = A[j];
        for (int a = 0; a < 3; a++) {  // 前面M中a的数量
            for (int b = 0; b < 3; b++) {  // 后面X中b的数量
                ll cnt = (ll)prefix_m[j][a] * suffix_x[j + 1][b];
                ans += cnt * mex(a, e_val, b);
            }
        }
    }

    cout << ans << '\n';

}

int main(){
    solve();
    return 0;
}
```

## F

### Problem Statement

You are in a store to buy N items. The regular price of the i-th item is Pi​ yen (the currency in Japan).

You have M coupons. You can use the i-th coupon to buy an item whose regular price is at least Li​ yen at a Di​-yen discount.

Here, each coupon can be used only once. Besides, multiple coupons cannot be used for the same item.

If no coupon is used for an item, you will buy it for a regular price. Find the minimum possible total amount of money required to buy all the N items.

### Constraints

- 1≤N,M≤2×10^5
- 1≤Pi​≤10^9
- 1≤Di​≤Li​≤10^9
- All input values are integers.

##### 思路：

1.对所有P从小到大排序，对优惠券按照L从小到大排序

2.对于一个价格，若还有优惠券且L小于等于该，则将其D放入一个大顶堆的优先队列；若队列不空，则取出队头元素计算折扣后的价格。

##### 代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;


void solve(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int N,M;
    cin>>N>>M;

    vector<ll> P(N);
    vector<pair<ll,ll> >coupons(M);

    for(int i = 0 ; i < N ; i++){
        cin>>P[i];
    }


    for (int j = 0; j < M; ++j) {
        cin >> coupons[j].first;
    }
    for (int j = 0; j < M; ++j) {
        cin >> coupons[j].second;
    }

    sort(P.begin(), P.end());
    sort(coupons.begin(), coupons.end()); // sort by L_j
    priority_queue<ll> max_heap;
    ll total = 0;
    size_t j = 0;
    for (int i = 0; i < N; ++i) {
        ll price = P[i];
        // Add all coupons with L_j <= price to the heap
        while (j < M && coupons[j].first <= price) {
            max_heap.push(coupons[j].second);
            ++j;
        }
        // The best coupon is the one with max D_j
        if (!max_heap.empty()) {
            total += max(0LL, price - max_heap.top());
            max_heap.pop();
        } else {
            total += price;
        }
    }
    cout << total << '\n';



}

int main(){
    solve();
    return 0;
}
```
