### 题目1：POJ3253

题目：

约翰想修牧场周围的篱笆，需要 N 块（1≤N≤20000）木板，每块木板都具有整数长度 Li（1≤Li≤50000）米。他购买了一块足够长的木板（长度为 Li 的总和，
i=1,2,…, N），以便得到 N 块木板。切割时木屑损失的长度不计。
农夫唐向约翰收取切割费用。切割一块木板的费用与其长度相同。切割长度为 21 米的木板需要 21 美分。唐让约翰决定切割木板的顺序和位置。约翰知道以不同的顺序切割木板，将会产生不同的费用。帮助约翰确定他得到 N 块木板的最低金额。



思路：

1.利用哈夫曼树的构造即可得到最低金额

2.使用优先队列来每次获取两个最小权值



代码：

```c++
#include<iostream>
#include<cstdio>
#include<cstring>
#include<stdio.h>
#include<queue>
using namespace std;

int main(){
	long long sum = 0;
	int n ,t, t1 ,t2 ;
	
	while(cin>>n){
		priority_queue<int , vector<int> , greater<int> >q;
		for(int i = 0 ; i < n ; i++){
			cin>>t;
			q.push(t);
		}
		
		sum = 0;
		while(q.size() > 1){
			t1 = q.top();q.pop();
			t2 = q.top();q.pop();
			t = t1 + t2;
			sum += t;
			q.push(t);
			
		}
		cout<<sum<<endl;
	}
	return 0;
}
```





### 题目2：POJ1521

题目：

熵编码是一种数据编码方法，通过对去除“冗余”或“额外”信息的消息进行编码来实现无损数据压缩。为了能够恢复信息，编码字形的位模式不允许作为任何其他编码位模式的前缀，称之为“无前缀可变长度”编码。只允许逐位读取编码的比特流，并且每当遇到表示字形的一组比特时，都可以解码该字形。如果不强制使用无前缀约束，则不可能进行这种解码。
第 1 个例子，考虑文本“AAAAABCD”，对其使用 8 位 ASCII 编码需要 64 位。如果用“00”对“A”编码，用 “01”对“B”编码，用“10”对“C”编码，用“11”对“D”编码，那么
只需 16 位编码，得到的位模式将是“0000000000011011”。不过，这仍然是固定长度的编码；使用的是每个字形两位，而不是八位。既然字形“A”出现的频率更高，那么能用更少的位来编码它吗？实际上可以，但为了保持无前缀编码，其他一些位模式将变得比两位长。最佳编码是将“A”编码为“0”，将“B”编码为“10”，将“C”编码为“110”，将“D”编码为“111”这显然不是唯一的最佳编码，因为 B、C 和 D 的编码可以在不增加最终编码消息大小的情况下自由地交换给任何给定的编码）。使用此编码，消息仅以 13 位编码到“0000010110111”，压缩比为 4.9:1（即最终编码消息中的每一位表示的信息与原始编码中的 4.9 位表示的信息相同）。从
左到右阅读这个位模式，将看到无前缀编码使得将其解码为原始文本变得简单，即使代码的位长度不同。
第 2 个例子，考虑文本“THE CAT IN THE HAT”。字母“T”和空格字符都以最高频率出现，因此它们在最佳编码中显然具有最短的编码位模式。字母“C”、“I”和“N”只出现一次，因此它们的代码最长。有许多可能的无前缀可变长度位模式集可以产生最佳编码，也就是说，允许文本以最少的位进行编码。其中一种最佳编码是：空格:00、A:100、C:1110、E:1111、H:110、I:1010、N:1011、T:01。因此，这种最佳编码只需 51 位，与用 8 位 ASCII 编码对消息进行编码所需的 144 位相比，压缩比为 2.8:1。



思路：

1.使用一个数组a[]来记录每种字符出现次数，即为频率

2.构造哈夫曼树，并记录新构造节点的权值总和，即为总编码长度



代码：

```c++
#include<cstdio>
#include<string>
#include<stdio.h>
#include<queue>
#include<iostream>
#include<cstring>
using namespace std;

int a[30];
int main(){
	string s;
	while(true){
		cin>>s;
		if( s == "END")break;
		memset(a,0,sizeof(a));
		
		int n = s.size();
		
		for(int i = 0 ; i < n ; i++){
			if( s[i] == '_'){
				a[26]++;
			}else{
				a[s[i] - 'A']++;
			}
		}
		
		priority_queue<int , vector<int> , greater<int> >q;
		
		for(int i = 0 ; i <= 26 ; i++){
			if(a[i] != 0){
				q.push(a[i]);
			}
		}
		
		int ans = n;
		
		while(q.size() > 2){
			int t,t1,t2;
			t1 = q.top();q.pop();
			t2 = q.top(); q.pop();
			t = t1 + t2;
			q.push(t);
			ans += t;
			
		}
		
		printf("%d %d %.1lf\n",n*8,ans,(double)n*8/ans);
		
	}
	return 0;
}
```





### 题目3：UVA12676

题目：

静态哈夫曼编码是一种主要用于文本压缩的编码算法。给定一个由 N 个不同字符组成的特定长度的文本，算法选择 N 个编码，每个不同的字符都对应一个编码。
使用这些编码压缩文本，当选择编码算法构建一个具有 N 个叶子的二叉树时，对于 N≥2，树的构建流程如下。
（1）对文本中的每个不同字符，都构建一个仅包含单个节点的树，其权值为该字符在文本中的出现次数。
（2）构建一个包含上述 N 棵树的集合 S。
（3）当 S 包含多于一棵树时：①选择最小的权值 t1∈S，并将其从 S 中删除；②选择最小的权值 t2∈S，并将其从 S 中删除；③构建一棵新树 t，t1 为其左子树，t2 为其右子树，t 的权值为t1、t2 权值之和；④将 t 加入 S 集合。

（4）返回保留在 S 中的唯一一棵树

对文本中的每个不同字符，其编码都取决于最终树中从根到对应字符的叶子之间的路径，编码的长度是这条路径中的边数。假设该算法构建的是左侧的树，“r”的代码长度为 3，“d”的代码长度为 4。根据算法选择的 N 个代码的长度，找所有字符总数的最小值。



思路：

1.利用哈夫曼树的构造原理，可知字符最大编码长度即为哈夫曼树深度；最底层节点权值至少为1；当前层节点权值至少是下一层节点权值最大值

2.使用数组deep[]来记录每一层节点的权值，初始化为0

3.从最大深度向上计算并推测，直到树根

4.第 i 层的节点权值如果为 0，则被初始化为 temp。对第 i 层从小到大排序，然后将第 i 层每两个合并，将权值放入上一层（i-1 层）更新 temp 为第 i 层排序后的
最后一个元素（最大元素）。



代码：

```c++
#include<bits/stdc++.h>

using namespace std;

int maxd;
const int MAX = 100;
vector<long long> deep[MAX];
int main(){
	int n,x;
	while(cin>>n){
		for(int i = 0 ; i < MAX; i++){
			deep[i].clear();
		}
		
		maxd = 0;
		for(int i = 0 ; i < n ; i++){
			cin>>x;
			deep[x].push_back(0);
			maxd = max(maxd,x);
		}
		
		long long temp = 1;
		for(int i = maxd ; i > 0 ; i--){
			for(int j = 0 ; j < deep[i].size() ; j++){
				if(deep[i][j] == 0){
					deep[i][j] = temp;
				}
			}
			
			sort(deep[i].begin() , deep[i].end());
			for(int j = 0 ; j < deep[i].size() ; j += 2){
				deep[i-1].push_back(deep[i][j] + deep[i][j+1]);
			}
			
			temp = *(deep[i].end()-1);
		}
		
		cout<<*deep[0].begin()<<endl;
		
	}
	
	return 0;
}
```

