### 题目1：P2240

题目：

阿里巴巴走进了装满宝藏的藏宝洞。藏宝洞里面有 N(N≤100) 堆金币，第 i 堆金币的总重量和总价值分别是 mi​,vi​(1≤mi​,vi​≤100)。阿里巴巴有一个承重量为 T(T≤1000) 的背包，但并不一定有办法将全部的金币都装进去。他想装走尽可能多价值的金币。所有金币都可以随意分割，分割完的金币重量价值比（也就是单位价格）不变。请问阿里巴巴最多可以拿走多少价值的金币？

思路：

1.使用贪心算法，尽量装单位价值高的金币

2.若背包装得下则全部把这堆金币装入，装不下则拿走能装下的部分

3.排序时要按照单位价值从大到小的顺序排列

代码：

```cpp
#include<bits/stdc++.h>

using namespace std;

struct Node{
    double w;
    double v;
    double p;
}a[105];

bool cmp(Node a,Node b){//从大到小排列 
    return a.p>b.p;
}

int main(){
    int n,t;
    scanf("%d%d",&n,&t);

    double t1,t2;
    for(int i = 0 ;i < n ; i++){
        scanf("%lf%lf",&t1,&t2);
        a[i].w = t1;
        a[i].v = t2;
        a[i].p = t2/t1;

    }

    sort(a,a+n,cmp);

    double res = 0.0;
    int i = 0;
    while(t > 0){
        if(i >= n)break;
        if(t >= a[i].w){
            res += a[i].v;
            t -= a[i].w;
            i++;
        }else{
            res += t*a[i].p;
            t = 0;
        }
    }

    printf("%.2lf\n",res);

    return 0;
}
```

### 题目2：P1223

题目：

有 n 个人在一个水龙头前排队接水，假如每个人接水的时间为 Ti​，请编程找出这 n 个人排队的一种顺序，使得 n 个人的平均等待时间最小。

如果两个人接水的时间相同，编号更小的人应当排在前面。

思路：

1.想要让平均等待时间最小，就要让所有人等待时间总和最小，因此让接水时间短的人先接水。

2.接水时间相同时注意编号小的在前

3.存储使用结构体数组来存储。遍历数组，当前的人接水时间×（总人数-已遍历人数）为其他人等待此人的时间总和。

代码：

```cpp
#include<bits/stdc++.h>

using namespace std;

struct Node{
    int label;
    int t;
}a[1005];

bool cmp(Node a , Node b){
    return a.t < b.t;
}

int main(){
    int n;
    cin>>n;
    int temp;
    double sum = 0.0;
    for(int i = 0 ; i < n ; i++){
        cin>>temp;
        a[i].label = i+1;
        a[i].t = temp;
    }

    sort(a,a+n,cmp);

    double res = 0.0;
    for(int i = 0 ; i < n ; i++){
        sum += a[i].t*(n-i - 1);
    }

    res = sum / n;

    for(int i = 0 ; i < n  ; i++){
        if(i != 0){
            cout<<" ";
        }

        cout<<a[i].label;
    }
    cout<<endl;
    printf("%.2lf",res);

    return 0;
}
```

### 题目3：P1803

题目：

现在各大 oj 上有 n 个比赛，每个比赛的开始、结束的时间点是知道的。

yyy 认为，参加越多的比赛，noip 就能考的越好（假的）。

所以，他想知道他最多能参加几个比赛。

由于 yyy 是蒟蒻，如果要参加一个比赛必须善始善终，而且不能同时参加 2 个及以上的比赛。

思路：

1.使用贪心算法，将区间按照结束时间从小到大排序，若结束时间相同则开始时间晚的区间在前

2.选择结束时间最早且与已安排比赛不冲突的比赛

代码：

```cpp
#include<bits/stdc++.h>

using namespace std;

struct interval{
    int start;
    int end;
}a[1000005];

bool cmp(interval x , interval y){
    if(x.end == y.end)return x.start > y.start;
    return x.end < y.end;
}

int main(){
    int n;
    cin>>n;
    int x,y;
    int cnt = 1;
    for(int i = 0 ; i < n ; i++){
        cin>>x>>y;
        a[i].start = x;
        a[i].end = y;
    }
    sort(a,a+n,cmp);

    int earliest_time_to_start = a[0].end;

    for(int i = 1 ; i < n ; i++){
        if(a[i].start >= earliest_time_to_start){
            earliest_time_to_start = a[i].end;
            cnt++;
        }
    }

    cout<<cnt<<endl;


    return 0;
}
```



### 题目4：P1923

题目：

输入 n（1≤n<5000000 且 n 为奇数）个数字 ai​（1≤ai​<109），输出这些数字的第 k 小的数。最小的数是第 0 小。

请尽量不要使用 `nth_element` 来写本题，因为本题的重点在于练习分治算法。



思路:

1.可以使用快速排序的划分来找到第k小的数，若划分的pivot位置mid为k则直接输出，若mid小于k则到（left,mid-1）之间去找目标，若mid大于k则到（mid+1，right）之间去找目标

2.由于题目数据量很大，可以进行读入加速



代码：

```cpp
#include<bits/stdc++.h>

using namespace std;
const int N = 5e6 + 10;
int n, k, a[N];


int partition(int left , int right , int *a){
	int k = left + rand()%(right-left+1);
	swap(a[k],a[left]);
	int i = left,j = right;
	int pivot = a[left];
	
	while(i < j ){
		while(a[j] > pivot && i < j)j--;
		if(i < j)a[i++] = a[j];
		
		while(a[i] < pivot  && i < j)i++;
		if(i < j)a[j--] = a[i];
	}
	a[i] = pivot;
	return i;
}

void findK(int left , int right , int *a , int k){
	int mid = partition(left,right,a);
	if( k == mid){
		cout<<a[k]<<endl;
	}else if( k < mid){
		findK(left,mid-1,a,k);
	}else{
		findK(mid+1,right,a,k);
	}
}

int main(){
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	cin>>n>>k;
	for(int i = 0 ; i < n ; i++){
		cin>>a[i];
	}
	
	findK(0,n-1,a,k);
	return 0;
}
```






