### 题目1：POJ1577

题目：

Consider the following sequence of operations on a binary search tree of letters  

Remove the leaves and list the data removed  Repeat this procedure until the tree is empty  Starting from the tree below on the left, we produce the sequence of trees shown, and then the empty tree

Your problem is to start with such a sequence of lines of leaves from a binary search tree of letters and output the preorder traversal of the tree.



思路：

1.按照输入顺序的倒序建立二叉排序树

2.前序遍历二叉排序树



代码：

```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<stack>
#include<vector>
using namespace std;

const int MAX = 1005;
typedef struct tagTree{
	tagTree *left,*right;
	char c;
	// 构造函数，方便初始化
    tagTree(char ch) : c(ch), left(nullptr), right(nullptr) {}
}Tree;

void insert(Tree &*p , char c){
	if(!p){
		p = new tagTree(c);
		return ;
	}
	
	if(c < p->character){
		insert(p->left,c);
	}else{
		insert(p->right,c);
	}
}

void preorder(Tree *p){
	if(!p){
		cout<<p->character;
	} 
	
	preorder(p->left);
	preorder(p->right);
}

int main(){
	string s1,s;
	while(true){
		s = "";
		Tree *root = nullptr;
		
		
		while (cin >> s1) {
            if (s1[0] == '*' || s1[0] == '$') break;
            s += s1;
        }
		cnt = 1;
		for(int i = s.length() - 1; i >= 0 ; i--){
			insert(root,s[i]);
		}
		
		preorder(root);
		
		cout<<endl;
		if(s1[0] == '$')break;
	}
	return 0;
}
```





### 题目2：POJ2309

题目：

Consider an infinite full binary search tree (see the figure below), the numbers in the nodes are 1, 2, 3, .... In a subtree whose root node is X, we can get the minimum number in this subtree by repeating going down the left node until the last level, and we can also find the maximum number by going down the right node. Now you are given some queries as "What are the minimum and maximum numbers in the subtree whose root node is X?" Please try to find answers for there queries.



思路：

1.记录输入root的值能够除以几次2，记为k

2.最小值即为root左子树最左叶子节点值，最大值即为root右子树最右节点值

3.最左叶子节点值为root-(2^k) - 1,最右节点值root+(2^k) - 1



代码：

```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<stack>
#include<vector>

using namespace std;

int lowbit(int n){//获取n在BST从下往上数第几层 
	return n&(-n);
}

int main(){
	int N;
	cin>>N;
	int X,k;
	while(N--){
		cin>>X;
		k = lowbit(X)-1;
		cout<<X-k<<" "<<X+k<<endl; 
	}
	return 0;
}
```






