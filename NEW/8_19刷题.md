### 题目1：P1739

题目：

假设一个表达式有英文字母（小写）、运算符（`+`、`-`、`*`、`/`）和左右小（圆）括号构成，以 `@` 作为表达式的结束符。请编写一个程序检查表达式中的左右圆括号是否匹配，若匹配，则输出 `YES`；否则输出 `NO`。表达式长度小于 255，左圆括号少于 20 个。



思路：使用栈来存放左括号，遇到右括号出栈栈顶元素，若栈空则不符合条件；若表达式遍历完且栈非空，则不符合；其余情况则符合。



代码：

```c++
#include<bits/stdc++.h>

using namespace std;

int main(){
	stack<char> s;
	string str;
	cin>>str;
	bool flag = true;
	for(int i = 0 ; i < str.size() ; i++){
		if(str[i] == '('){
			s.push(str[i]);
		}else if(str[i] == ')'){
			if(s.empty()){
				flag  = false;
				break;
			}else{
				s.pop();
			}
		}
	}
	
	if(!s.empty()){
		flag = false;
	}
	
	if(flag){
		cout<<"YES"; 
	}else{
		cout<<"NO";
	}
	return 0;
}
```





### 题目2：P2670

题目：扫雷游戏是一款十分经典的单机小游戏。在 n行 m列的雷区中有一些格子含有地雷（称之为地雷格），其他格子不含地雷（称之为非地雷格）。玩家翻开一个非地雷格时，该格将会出现一个数字——提示周围格子中有多少个是地雷格。游戏的目标是在不翻出任何地雷格的条件下，找出所有的非地雷格。

现在给出 n行 m列的雷区中的地雷分布，要求计算出每个非地雷格周围的地雷格数。

注：一个格子的周围格子包括其上、下、左、右、左上、右上、左下、右下八个方向上与之直接相邻的格子。



思路：

1.使用二维数组存放读入的格子、要记录的附近的地雷个数

2.使用二维数组存放移动的八个方向

3.对于遍历到的格子，检查它周围的八个方向的格子，记录周围地雷个数

4.使用一个方法CHECK来判断是否是合法坐标



代码：

```c++
#include<bits/stdc++.h>

using namespace std;

const int MAX = 110;

char a[MAX][MAX];
int b[MAX][MAX];
int dir[8][2] = {{-1,1},{-1,-1},{-1,0},{0,1},{0,-1},{1,1},{1,0},{1,-1}};
int n,m;

bool CHECK(int x, int y){
	if(x >= 0 && x < n && y >= 0 && y < m){
		return true;
	}else{
		return false;
	}
}

int getNum(int x , int y){
	int cnt = 0;
	for(int i = 0 ; i < 8 ; i++){
		int nx = x + dir[i][0];
		int ny = y + dir[i][1];
		
		if(CHECK(nx,ny)){
			if(a[nx][ny] == '*'){
				cnt++;
			}
		}else{
			
		}
	}
	
	return cnt;
} 

int main(){
	cin>>n>>m;
	for(int i = 0 ; i < n ; i++){
		for(int j = 0 ; j < m ; j++){
			cin>>a[i][j];
		}
	}
	
	for(int i = 0 ; i < n ; i++){
		for(int j = 0 ; j < m ; j++){
			if(a[i][j] == '*'){
				b[i][j] = -1;
			}else{
				int cnt = getNum(i,j);
				b[i][j] = cnt;
			}
		}
	}
	
	for(int i = 0 ; i < n ; i++){
		for(int j = 0 ; j < m ; j++){
			if(b[i][j] == -1){
				cout<<"*";
			}else{
				cout<<b[i][j];
			}
		}
		cout<<endl;
	}
	
	return 0;
}
```





### 题目3：P1563

题目：

输入的第一行包含两个正整数 n,m表示玩具小人的个数和指令的条数。

接下来 n行，每行包含一个整数和一个字符串，以逆时针为顺序给出每个玩具小人的朝向和职业。其中 0表示朝向圈内，1表示朝向圈外。保证不会出现其他的数。字符串长度不超过 10且仅由英文字母构成，字符串不为空，并且字符串两两不同。整数和字符串之间用一个空格隔开。

接下来 m行，其中第 i行包含两个整数 ai,si，表示第 i条指令。若 ai=0，表示向左数 si个人；若 ai=1，表示向右数 si个人。 保证 ai不会出现其他的数，1≤si<n。



思路：

1.使用结构体，将每个玩具对象抽象为存储面向和名字的对象；结构体数组存放读入的所有玩具

2.模拟寻找小人过程时，若面向向内则移动方向与读入指令一致；若面向向外则移动方向与读入指令相反

3.逆时针移动时，移动到的位置pos = (当前位置 + 移动步数)mod n;顺时针移动时，移动到的位置pos = (当前位置 + n - 移动步数)mod n

代码：

```c++
#include<bits/stdc++.h>

using namespace std;

const int N = 1e5 + 10;
struct Node{
	int dir;
	string name;
}toys[N];

int n,m;

int main(){
	
	cin>>n>>m;
	for(int i = 0 ; i < n ; i++){
		cin>>toys[i].dir>>toys[i].name;
	}
	
	int pos = 0;
	
	for(int i = 0 ; i < m ; i++){
		int d,step;
		cin>>d>>step;
		if(toys[pos].dir == 0){
			if(d == 0){
				pos = (pos - step + n)%n;
			}else{
				pos = (pos + step)%n;
			}
			
		}else{
			if(d == 0){
				pos = (pos + step)%n;
			}else{
				pos = (pos - step + n)%n;
			}
		}
	}
	
	cout<<toys[pos].name<<endl;
	return 0;
}
```







### 题目4：P1067

题目：

一元 n次多项式可用如下的表达式表示：

f(x)=anxn+an−1xn−1+⋯+a1x+a0,an≠0

其中，aix^i称为 i次项，ai称为 i次项的系数。给出一个一元多项式各项的次数和系数，请按照如下规定的格式要求输出该多项式：

1. 多项式中自变量为 x，从左到右按照次数递减顺序给出多项式。
2. 多项式中只包含系数不为 0的项。
3. 如果多项式 n次项系数为正，则多项式开头不出 `+` 号，如果多项式 n次项系数为负，则多项式以 `-` 号开头。
4. 对于不是最高次的项，以 `+` 号或者 `-` 号连接此项与前一项，分别表示此项系数为正或者系数为负。紧跟一个正整数，表示此项系数的绝对值（如果一个高于 0 次的项，其系数的绝对值为 1，则无需输出 1）。如果 x的指数大于 1，则接下来紧跟的指数部分的形式为“xb”，其中 b 为 x的指数；如果 x的指数为 1，则接下来紧跟的指数部分形式为 x；如果 x的指数为 0，则仅需输出系数即可。
5. 多项式中，多项式的开头、结尾不含多余的空格。



思路：

1.输出最高次项时，只有系数为负时才打印符号

2.输出完最高次项，则标记“最高次项已输出”，进入处理其余项的状态

3.处理每一项时，若系数为1，则输出x^b；若为若系数为-1，则输出-x^b；其余情况则输出ax^b

4.若输入的系数全为0，则输出0



代码：

```c++
#include<bits/stdc++.h>

using namespace std;

int main(){
	int n;
	cin>>n;
	bool HighestPrinted = false;
	bool HasPrinted = false;
	for(int i = 0 ; i <= n ; i++){
		int a ;
		cin>>a;
		if(!HighestPrinted){
			if(a == 0){
				
			}else{
				HighestPrinted = true;
				HasPrinted = true;
				if(a > 0){
					
					if(a == 1){
						if( i == n){
							cout<<a;
						}else if(i == n-1){
							cout<<"x";
						}else{
							cout<<"x^"<<n-i;
						}
					}
					else{
						if( i == n){
							cout<<a;
						}else if(i == n-1){
							cout<<a<<"x";
						}else{
							cout<<a<<"x^"<<n-i;
						}
					}
				}else{
					if(a == -1){
						if( i == n){
							cout<<"-1";
						}else if(i == n-1){
							cout<<"-x";
						}else{
							cout<<"-x^"<<n-i;
						}
					}
					else{
						if( i == n){
							cout<<a;
						}else if(i == n-1){
							cout<<a<<"x";
						}else{
							cout<<a<<"x^"<<n-i;
						}
					}
				}	
				

			}
		}else{
			if(a == 0){
				
			}else{
				HasPrinted = true;
				if(a > 0){
					cout<<"+";
				}
				
				if(i == n){
					cout<<a;
				}else if(i == n-1){
					if(a == -1){
						cout<<"-x";
					}else if(a == 1){
						cout<<"x";
					}else{
						cout<<a<<"x";
					}
					 
				}else{
					if(a == -1){
						cout<<"-x^"<<n-i;
					}else if(a == 1){
						cout<<"x^"<<n-i;
					}else{
						cout<<a<<"x^"<<n-i;
					}
				}
			}
		}
	}
	
	if(!HasPrinted){
		cout<<0;
	}
	cout<<endl;
	return 0;
}
```



