## A

### Problem Statement

Takahashi has recorded the number of steps he walked for N weeks. He walked Ai​ steps on the i-th day.

Find the total number of steps Takahashi walked each week.  
More precisely, find the sum of the steps for the first week (the 1-st through 7-th day), the sum of the steps for the second week (the 8-th through 14-th day), and so on.

### Constraints

- 1≤N≤10
- 0≤Ai​≤10^5
- All input values are integers.

##### 代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;



void solve(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);



    int N;
    cin>>N;
    ll walk[7*N];
    for(int i = 0 ; i < 7*N ; i++){
        cin>>walk[i];
    }

    for(int i = 0 ; i < N ; i++){
        if(i != 0)cout<<" ";

        ll temp = 0LL;
        for(int j = 0 ; j < 7 ; j++){
            temp += walk[7*i + j];
        }
        cout<<temp;
    }
}

int main(){
    solve();
    return 0;
}
```

## B

### Problem Statement

You are given N strings S1​,S2​,…,SN​ consisting of lowercase English letters.  
Determine if there are **distinct** integers i and j between 1 and N, inclusive, such that the concatenation of Si​ and Sj​ in this order is a palindrome.

A string T of length M is a palindrome if and only if the i-th character and the (M+1−i)-th character of T are the same for every 1≤i≤M.

### Constraints

- 2≤N≤100
- 1≤∣Si​∣≤50
- N is an integer.
- Si​ is a string consisting of lowercase English letters.
- All Si​ are distinct.

##### 思路：

注意拼接时两种顺序都要考虑

##### 代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;


bool predicates(string s){
    int len = s.size();
    int i = 0 ; int j = len - 1;
    while(i <= j){
        if(s[i] != s[j])return false;
        else{
            i++;
            j--;
        }
    }
    return true;
}

void solve(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int N;
    cin>>N;
    string res[N];
    bool flag = false;

    for(int i = 0 ; i < N ; i++){
        cin>>res[i];
    }

    for(int i = 0 ; i < N - 1 ; i++){
        for(int j = i + 1 ; j < N ; j++){
            string temp1 = res[i] + res[j];
            string temp2 = res[j] + res[i];
            if(predicates(temp1) || predicates(temp2)){
                flag = true;
                break;
            }
        }
    }

    if(flag){
        cout<<"Yes"<<endl;
    }else{
        cout<<"No"<<endl;
    }

}

int main(){
    solve();
    return 0;
}
```

## D

### Problem Statement

You are given a string S of length N consisting of lowercase English letters and the characters `(` and `)`.  
Print the string S after performing the following operation as many times as possible.

- Choose and delete a contiguous substring of S that starts with `(`, ends with `)`, and does not contain `(` or `)` other than the first and last characters.

It can be proved that the string S after performing the operation as many times as possible is uniquely determined without depending on how it is performed.

### Constraints

- 1≤N≤2×10^5
- N is an integer.
- S is a string of length N consisting of lowercase English letters and the characters `(` and `)`.

##### 思路：

1.使用栈存入读入的S的字符，若遇到‘）’则出栈至弹出‘（’，前提是栈中已至少有一个‘（’

##### 代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

void solve(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int N;
    char ch;
    stack<char> s;
    vector<char> res;
    cin>>N;
    int num = 0;
    for(int i = 0 ; i < N ; i++){
        cin>>ch;
        if(ch != ')'){
            s.push(ch);
            if(ch == '('){
                num++;
            }
        }else{
            if(num == 0){
                s.push(ch);

            }else{
                while(!s.empty()){
                    if(s.top() == '('){
                        s.pop();
                        break;
                    }else{
                        s.pop();
                    }
                }

                num--;
            }
        }
    }
    int cnt = 0;

    if(s.empty()){

    }else{
        while(!s.empty()){
        res.emplace_back(s.top());
        cnt++;
        s.pop();
        }


        for(int i = cnt-1 ; i >= 0 ; i--){
            cout<<res[i];
        }
    }


}

int main(){
    solve();
    return 0;
}
```

## C

### Problem Statement

Takahashi has two sheets A and B, each composed of black squares and transparent squares, and an infinitely large sheet C composed of transparent squares.  
There is also an ideal sheet X for Takahashi composed of black squares and transparent squares.

The sizes of sheets A, B, and X are HA​ rows × WA​ columns, HB​ rows × WB​ columns, and HX​ rows × WX​ columns, respectively.  
The squares of sheet A are represented by HA​ strings of length WA​, A1​,A2​,…,AHA​​ consisting of `.` and `#`.  
If the j-th character (1≤j≤WA​) of Ai​ (1≤i≤HA​) is `.`, the square at the i-th row from the top and j-th column from the left is transparent; if it is `#`, that square is black.  
Similarly, the squares of sheets B and X are represented by HB​ strings of length WB​, B1​,B2​,…,BHB​​, and HX​ strings of length WX​, X1​,X2​,…,XHX​​, respectively.

Takahashi's goal is to create sheet X using **all black squares** in sheets A and B by following the steps below with sheets A, B, and C.

1. Paste sheets A and B onto sheet C along the grid. Each sheet can be pasted anywhere by translating it, but it cannot be cut or rotated.
2. Cut out an HX​×WX​ area from sheet C along the grid. Here, a square of the cut-out sheet will be black if a black square of sheet A or B is pasted there, and transparent otherwise.

Determine whether Takahashi can achieve his goal by appropriately choosing the positions where the sheets are pasted and the area to cut out, that is, whether he can satisfy both of the following conditions.

- The cut-out sheet includes **all black squares** of sheets A and B. The black squares of sheets A and B may overlap on the cut-out sheet.
- The cut-out sheet coincides sheet X without rotating or flipping.

### Constraints

- 1≤HA​,WA​,HB​,WB​,HX​,WX​≤10
- HA​,WA​,HB​,WB​,HX​,WX​ are integers.
- Ai​ is a string of length WA​ consisting of `.` and `#`.
- Bi​ is a string of length WB​ consisting of `.` and `#`.
- Xi​ is a string of length WX​ consisting of `.` and `#`.
- Sheets A, B, and X each contain at least one black square.

##### 思路：

1. 将问题转化为在虚拟大画布上可能的盖印位置
2. 枚举所有合理的盖印位置组合
3. 检查每种组合是否符合目标网格的要求
4. 找到符合条件的组合后立即输出结果

##### 代码：

```cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 30, MID = 10;
int ha, wa, hb, wb, hx, wx;
vector <vector <char>> A, B, X, C;

void init(vector <vector <char>> &C)
{
    C.resize(N);
    for (auto &s : C)
    {
        s.resize(N);
        for (auto &c : s)    c = '.';
    }
}

void read(int &h, int &w, vector <vector <char>> &M)
{
    scanf("%d%d", &h, &w);
    M.resize(h);
    for (auto &s : M)
    {
        s.resize(w);
        for (auto &c : s)    scanf(" %c", &c);
    }
}

void fill(int p, int q, vector <vector <char>> M, vector <vector <char>> &C)
{
    int h = M.size(), w = M[0].size();
    for (int i = p; i < p + h; i++)
        for (int j = q; j < q + w; j++)
        {
            if (C[i][j] == '#' && M[i - p][j - q] == '.')    continue;        
            C[i][j] = M[i - p][j - q];    
        }
}

bool check(vector <vector <char>> X, vector <vector <char>> C)
{
    int h = X.size(), w = X[0].size();
    for (int i = MID; i < MID + h; i++)
        for (int j = MID; j < MID + w; j++)
        {
            if (X[i - MID][j - MID] != C[i][j])    return false;
            C[i][j] = '*';
        }
    for (auto &s : C)
        for (auto &x : s)
            if (x == '#')
                return false;
    return true;
}

int main()
{
    read(ha, wa, A);    read(hb, wb, B);    read(hx, wx, X);
    for (int i = 0; i <= N - MID; i++)
        for (int j = 0; j <= N - MID; j++)
            for (int p = 0; p <= N - MID; p++)
                for (int q = 0; q <= N - MID; q++)
                {
                    init(C);
                    fill(i, j, A, C);
                    fill(p, q, B, C);
                    if (check(X, C))    
                    {
                        printf("Yes");
                        return 0;
                    }
                }
    printf("No");
    return 0;
}
```

## E

### Problem Statement

There are N people numbered from 1 to N standing in a circle. Person 1 is to the right of person 2, person 2 is to the right of person 3, ..., and person N is to the right of person 1.

We will give each of the N people an integer between 0 and M−1, inclusive.  
Among the MN ways to distribute integers, find the number, modulo 998244353, of such ways that no two adjacent people have the same integer.

### Constraints

- 2≤N,M≤10^6
- N and M are integers.

##### 思路：

1.使用动态规划来解决这个问题

2.dp[n][2]中，0代表和第一个位置选择不同，1代表选择相同

3.若和第一个位置选择相同，则情况数和dp[n-1][0]相同；若若和第一个位置选择不同，则情况数为dp[i-1][0]*(m-2) + dp[i-1][1] *(m-1)

##### 代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

const ll N = 1e6 + 10, MOD = 998244353;
ll dp[N][2];


void solve(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n,m;
    cin>>n>>m;
    dp[1][1] = m;
    for(int i = 2 ; i <= n ; i++){
        dp[i][1] = dp[i-1][0];

        dp[i][0] = ((dp[i-1][0]*(m-2)) + (dp[i-1][1]*(m-1))) % MOD;
    }

    cout<<dp[n][0]<<endl;

}

int main(){
    solve();
    return 0;
}
```
