### 题目1：P1305

题目：

输入一棵二叉树，输出其先序遍历序列。



思路：

1.使用数组静态存储二叉树每个节点的左右孩子

2.对二叉树进行先序遍历



代码：

```c++
#include<bits/stdc++.h>

using namespace  std;
int n;
int root,lc[100],rc[100];
string s;

void preorder(int t){
	if(t != '*' - 'a'){
		cout<<char(t + 'a');
		preorder(lc[t]);
		preorder(rc[t]);
	}
}

int main(){
	cin>>n;
	for(int i = 0 ; i < n ; i++){
		cin>>s;
		if(!i){
			root = s[0] - 'a';
		}
		
		lc[s[0] - 'a'] = s[1] - 'a';
		rc[s[0] - 'a'] = s[2] - 'a';
		
	}
	preorder(root);
	
	return 0;
}
```





### 题目2：B3642

题目：

有一棵由 n（n≤106）个节点组成的二叉树。现给出每个节点的两个孩子的编号（均不超过 n），请构造一棵二叉树（根的编号为 1），若是叶子，
则输入 0 0。构造好这棵二叉树之后，依次求出它的先序遍历序列、中序遍历序列和后序遍历序列。



思路：

1.使用数组静态存储二叉树每个节点的左右孩子

2.对二叉树进行先序、中序、后序遍历



代码：

```c++
#include<bits/stdc++.h>

using namespace  std;
int n;

const int MAX = 1000010;

int root,lc[MAX],rc[MAX];

void preorder(int t){
	if(t != 0){
		cout<<t<<" ";
		preorder(lc[t]);
		preorder(rc[t]);
	}
}

void inorder(int t){
	if(t != 0){
		inorder(lc[t]);
		cout<<t<<" ";
		inorder(rc[t]);
	}
}

void postorder(int t){
	if(t != 0){
		postorder(lc[t]);
		postorder(rc[t]);
		cout<<t<<" ";
	}
}

int main(){
	cin>>n;
	for(int i = 1; i <= n ; i++){
		int a,b;
		cin>>a>>b;
		lc[i] = a;
		rc[i] =b;
	}
	
	preorder(1);
	cout<<endl;
	inorder(1);
	cout<<endl;
	postorder(1);
	return 0;
}
```





### 题目3：

题目：

给出二叉树的中序遍历和后序遍历，还原这棵二叉树，求出所有叶子节点中，到根节点路径上的所有点的编号和最小的叶子节点的值，若有多个这样的叶子节点，取其中值最小的



思路：

1.使用数组存放中序序列、后序序列、节点左孩子、节点右孩子

2.根据中序序列、后序序列构造出二叉树，即根据中序序列、后序序列将节点填入节点左孩子、节点右孩子数组中

3.寻找编号和最小的叶子节点时，选择使用minsum和minv全局变量记录最小节点值之和和最小叶节点值。若遇到叶节点则比较当前路径和是否比minsum小或者路径和相同且当前节点值比minv小，若符合则更新minsum和minv；否则递归处理左子树和右子树。



代码：

```c++
#include<bits/stdc++.h>

using namespace std;
const int MAX = 10005;
int inorder[MAX],postorder[MAX];
int lch[MAX],rch[MAX];
int n = 0;
int minsum = 0x3f3f3f3f;
int minv = 0x3f3f3f3f;
int createTree(int l1 , int l2 , int m){//由遍历序列创建二叉树
	if(m <= 0) return 0;
	int root = postorder[l2 + m -1];
	int len = 0;
	while(inorder[l1 + len] != root){//计算左子树的长度
		len++;
	}
	
	lch[root] = createTree(l1,l2,len);
	rch[root] = createTree(l1 + len + 1,l2 + len,m - len - 1);
	return root;
}

bool readLine(int *a){//读入遍历序列，中间有空格
	string line;
	if(!getline(cin,line)){
		return false;
	}
	
	stringstream s(line);
	n = 0;
	int x;
	while(s>>x){
		a[n++] = x;
	}
	return n>0;
}

void findMin(int v , int sum){
	sum += v;
	if(!lch[v] && !rch[v]){//叶子
		if((sum < minsum) || (sum == minsum && v < minv) ){
			minv = v;
			minsum = sum;
		}
	}
	
	if(lch[v]){
		findMin(lch[v],sum);
	}
	
	if(rch[v]){
		findMin(rch[v],sum);
	}
}

int main(){
	while(readLine(inorder)){//读入中序序列
		readLine(postorder);//读入后序序列
		
		createTree(0,0,n);
		minsum = 0x3f3f3f3f;
		minv = 0x3f3f3f3f;
		findMin(postorder[n-1],0);
		cout<<minv<<endl;
	}
	
	return 0;
}
```

